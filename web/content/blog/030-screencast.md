---
title: "#30: Bot tester: Accepting DM invites"
date: 2022-11-29
draft: true
featureImage: https://assets.gradesta.com/vegan-buddies/img/dalle2-open-doors.png
---

So I want to accept the invite if I am a bot. First I need to find out that the bot has been invited. Right now, we are listening to `OriginalSyncRoomMessageEvent`, which is only getting `Joined(room)` message events. It's not clear from the docs which event I should use for listening for invites. Could it be [`ThirdPartyInvite`](https://docs.rs/ruma/latest/ruma/events/room/member/struct.ThirdPartyInvite.html)? That doesn't sound very promissing. I'm guessing that event is triggered when someone else in a room that you are in invites someone to the room. Maybe its [`CallInviteEvent`](https://docs.rs/ruma/latest/ruma/events/call/invite/type.CallInviteEvent.html)? That seems more likely to be triggered when WE invite someone, rather than when we're invited. It's not clear that I can find out for sure without testing out multiple event handlers and seeing if they get triggered when the invite comes through. `CallInviteEvent`'s doc string is "An m.call.invite event." which clarifys things as far as to show that this code was done in a rote manner, copying over a list of items from somewhere else, or autogenerated. Wait....

It seems like there is a bug in `docs.rs`. The full doc strings are not being shown. Here is the full source for the event:

```
/// The content of an `m.call.invite` event.
///
/// This event is sent by the caller when they wish to establish a call.
#[derive(Clone, Debug, Deserialize, Serialize, EventContent)]
#[cfg_attr(not(feature = "unstable-exhaustive-types"), non_exhaustive)]
#[ruma_event(type = "m.call.invite", kind = MessageLike)]
pub struct CallInviteEventContent {
    /// A unique identifier for the call.
    pub call_id: OwnedVoipId,

    #[cfg(feature = "unstable-msc2746")]
    /// **Required in VoIP version 1.** A unique ID for this session for the duration of the call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub party_id: Option<OwnedVoipId>,

    /// The time in milliseconds that the invite is valid for.
    ///
    /// Once the invite age exceeds this value, clients should discard it. They should also no
    /// longer show the call as awaiting an answer in the UI.
    pub lifetime: UInt,

    /// The session description object.
    pub offer: OfferSessionDescription,

    /// The version of the VoIP specification this messages adheres to.
    pub version: VoipVersionId,

    #[cfg(feature = "unstable-msc2746")]
    /// **Added in VoIP version 1.** The VoIP capabilities of the client.
    #[serde(default, skip_serializing_if = "CallCapabilities::is_default")]
    pub capabilities: CallCapabilities,

    #[cfg(feature = "unstable-msc2746")]
    /// **Added in VoIP version 1.** The intended target of the invite, if any.
    ///
    /// If this is `None`, the invite is intended for any member of the room, except the sender.
    ///
    /// The invite should be ignored if the invitee is set and doesn't match the user's ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invitee: Option<OwnedUserId>,
}
```

Well at least now we know two things.

1. Searching docs < reading source code
2. `CallInviteEvent` is triggered when you are invited to a VOIP(Voice Over IP) phone call

Here is the real doc string for `ThirdPartyInviteEvent`:

```
/// The content of an `m.room.third_party_invite` event.
///
/// An invitation to a room issued to a third party identifier, rather than a matrix user ID.
///
/// Acts as an `m.room.member` invite event, where there isn't a target user_id to invite. This
/// event contains a token and a public key whose private key must be used to sign the token.
/// Any user who can present that signature may use this invitation to join the target room.
```

While snooping around I also found this:

```
    /// The kind of membership events to filter for.
    #[doc = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/src/doc/string_enum.md"))]
    #[derive(Clone, Debug, PartialEq, Eq, StringEnum)]
    #[ruma_enum(rename_all = "lowercase")]
    #[non_exhaustive]
    pub enum MembershipEventFilter {
        /// The user has joined.
        Join,

        /// The user has been invited.
        Invite,

        /// The user has left.
        Leave,

        /// The user has been banned.
        Ban,

        #[doc(hidden)]
        _Custom(PrivOwnedStr),
    }
```

Seems to relate to other users though. Though it does seem that somehow this can be used to get invite events.

Unfortunately, snooping through ruma doesn't seem to be helping. Another thing I'll attempt, is looking through [matrix-rust-sdk example programs](https://github.com/matrix-org/matrix-rust-sdk/tree/main/examples) to see if any of them accept an invite. The [autojoin](https://github.com/matrix-org/matrix-rust-sdk/tree/main/examples) example looks super prommissing.

It seems that it has an event handler that can get Invite events and join rooms. Just what we want, but when I set it up, no room invite events are being triggered.

Probably this is because I'm not running:

```
        client.sync(SyncSettings::default()).await;
```

But how can I do that and still have my message send/recieve loop? Seems like this does the trick after some fiddling with ownership of the `cleint` object.

```
    tokio::spawn(async move {
        client.sync(SyncSettings::default()).await;
    });
```

Now we end up with another problem. It turns out that the event handler `OriginalSyncRoomMessageEvent` actually gets ALL messages, including ones we send ourselves :O . We'll need to filter those by sender so we end up only processing messages that the other party sent. Unfortunately, I cannot find how `OriginalSyncRoomMessageEvent` is defined in source code. I'm importing it via `matrix_rust_sdk` from a re-exported `ruma` but when I do:

```
[timothy@nixos:~/pu/vegan-buddies/third-party/ruma]$ git grep OriginalSyncRoomMessageEvent
crates/ruma-common/src/doc/rich_reply.md:[`OriginalSyncRoomMessageEvent`], you have to convert it first by calling

[timothy@nixos:~/pu/vegan-buddies/third-party/ruma]$
```

I find it's not defined in `ruma`. When I search docs.rs I get something even weirder. I get [doc entry](https://docs.rs/ruma/latest/ruma/events/room/message/type.OriginalSyncRoomMessageEvent.html) as if it WAS defined in ruma. But clicking on the source link leads me to a [seamingly unrelated struct](https://docs.rs/ruma-common/0.10.3/src/ruma_common/events/room/message.rs.html#51). I also don't see where it might be defined in `matrix_rust_sdk`, though its certainly used a lot there. Could it be comming from some sort of macro?
    
```
[timothy@nixos:~/pu/vegan-buddies/third-party/matrix-rust-sdk]$ git grep OriginalSyncRoomMessageEvent
crates/matrix-sdk/src/client/mod.rs:    ///     ruma::events::room::message::OriginalSyncRoomMessageEvent, Client,
crates/matrix-sdk/src/client/mod.rs:    /// client.add_event_handler(|ev: OriginalSyncRoomMessageEvent| async move {
crates/matrix-sdk/src/client/mod.rs:    ///     ruma::events::room::message::OriginalSyncRoomMessageEvent, Client,
crates/matrix-sdk/src/client/mod.rs:    /// client.add_event_handler(|ev: OriginalSyncRoomMessageEvent| async move {
crates/matrix-sdk/src/room/timeline/event_item.rs:use ruma::events::room::message::{OriginalSyncRoomMessageEvent, Relation};
crates/matrix-sdk/src/room/timeline/event_item.rs:    pub fn _new(ev: OriginalSyncRoomMessageEvent, raw: Raw<AnySyncTimelineEvent>) -> Self {
examples/command_bot/src/main.rs:        MessageType, OriginalSyncRoomMessageEvent, RoomMessageEventContent,
examples/command_bot/src/main.rs:async fn on_room_message(event: OriginalSyncRoomMessageEvent, room: Room) {
examples/custom_events/src/main.rs:                message::{MessageType, OriginalSyncRoomMessageEvent},
examples/custom_events/src/main.rs:async fn on_regular_room_message(event: OriginalSyncRoomMessageEvent, room: Room) {
examples/emoji_verification/src/main.rs:            room::message::{MessageType, OriginalSyncRoomMessageEvent},
examples/emoji_verification/src/main.rs:    client.add_event_handler(|ev: OriginalSyncRoomMessageEvent, client: Client| async move {
examples/getting_started/src/main.rs:        message::{MessageType, OriginalSyncRoomMessageEvent, RoomMessageEventContent},
examples/getting_started/src/main.rs:async fn on_room_message(event: OriginalSyncRoomMessageEvent, room: Room) {
examples/image_bot/src/main.rs:    ruma::events::room::message::{MessageType, OriginalSyncRoomMessageEvent},
examples/image_bot/src/main.rs:async fn on_room_message(event: OriginalSyncRoomMessageEvent, room: Room, image: Arc<[u8]>) {
examples/login/src/main.rs:        MessageType, OriginalSyncRoomMessageEvent, RoomMessageEventContent, TextMessageEventContent,
examples/login/src/main.rs:async fn on_room_message(event: OriginalSyncRoomMessageEvent, room: Room) {
examples/login/src/main.rs:        if let OriginalSyncRoomMessageEvent {
examples/wasm_command_bot/src/lib.rs:            room::message::{MessageType, OriginalSyncRoomMessageEvent, RoomMessageEventContent},
examples/wasm_command_bot/src/lib.rs:    async fn on_room_message(&self, room_id: &RoomId, event: &OriginalSyncRoomMessageEvent) {

[timothy@nixos:~/pu/vegan-buddies/third-party/matrix-rust-sdk]$
```

At this point I've run out of time. I did mannage to figure out how to join rooms that I've been invited too, so at least I achieved that objective.

{{<screencast "2022-11-29-2169eabc-5e9e-406f-a10c-50def7a8ca65">}}
